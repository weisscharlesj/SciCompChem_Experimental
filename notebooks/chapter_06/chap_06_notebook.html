
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chapter 6: Signal &amp; Noise &#8212; Scientific Computing for Chemists</title>
    
  <link href="../../_static/css/theme.css" rel="stylesheet">
  <link href="../../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/sphinx-book-theme.css?digest=c3fdc42140077d1ad13ad2f1588a4309" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script src="../../_static/togglebutton.js"></script>
    <script src="../../_static/clipboard.min.js"></script>
    <script src="../../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../../_static/sphinx-book-theme.12a9622fbb08dcb3a2a40b2c02b83a57.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"processClass": "tex2jax_process|mathjax_process|math|output_area"}})</script>
    <script async="async" src="https://unpkg.com/thebe@0.5.1/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="Chapter 7: Image Processing &amp; Analysis" href="../chapter_07/chap_07_notebook.html" />
    <link rel="prev" title="Chapter 5: Pandas" href="../chapter_05/chap_05_notebook.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../../_static/logo.svg" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Scientific Computing for Chemists</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        <ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../../intro.html">
   Scientific Computing for Chemists
  </a>
 </li>
</ul>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_00/chap_00_notebook.html">
   Chapter 0: Python &amp; Jupyter Notebooks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_01/chap_01_notebook.html">
   Chapter 1: Basic Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_02/chap_02_notebook.html">
   Chapter 2: Intermediate Python
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_03/chap_03_notebook.html">
   Chapter 3: Plotting with Matplotlib
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_04/chap_04_notebook.html">
   Chapter 4: NumPy
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_05/chap_05_notebook.html">
   Chapter 5: Pandas
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Chapter 6: Signal &amp; Noise
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_07/chap_07_notebook.html">
   Chapter 7: Image Processing &amp; Analysis
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_08/chap_08_notebook.html">
   Chapter 8: Mathematics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_09/chap_09_notebook.html">
   Chapter 9: Simulations
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_10/chap_10_notebook.html">
   Chapter 10: Plotting with Seaborn
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_11/chap_11_notebook.html">
   Chapter 11: Nuclear Magnetic Resonance with NMRglue
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_12/chap_12_notebook.html">
   Chapter 12: Machine Learning using Scikit-Learn
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../chapter_13/chap_13.html">
   Chapter 13: Command Line &amp; Spyder
  </a>
 </li>
</ul>

    </div>
</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org/">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="topbar container-xl fixed-top">
    <div class="topbar-contents row">
        <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show"></div>
        <div class="col pl-md-4 topbar-main">
            
            <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
                data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
                aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
                title="Toggle navigation" data-toggle="tooltip" data-placement="left">
                <i class="fas fa-bars"></i>
                <i class="fas fa-arrow-left"></i>
                <i class="fas fa-arrow-up"></i>
            </button>
            
            
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../../_sources/notebooks/chapter_06/chap_06_notebook.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.ipynb</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

            <!-- Source interaction buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Connect with source repository"><i class="fab fa-github"></i></button>
    <div class="dropdown-buttons sourcebuttons">
        
        <a class="issues-button"
            href="https://github.com/executablebooks/jupyter-book/issues/new?title=Issue%20on%20page%20%2Fnotebooks/chapter_06/chap_06_notebook.html&body=Your%20issue%20content%20here."><button
                type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip" data-placement="left"
                title="Open an issue"><i class="fas fa-lightbulb"></i>open issue</button></a>
        
    </div>
</div>

            <!-- Full screen (wrap in <a> to have style consistency -->

<a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
        data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
        title="Fullscreen mode"><i
            class="fas fa-expand"></i></button></a>

            <!-- Launch buttons -->

<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn"
        aria-label="Launch interactive content"><i class="fas fa-rocket"></i></button>
    <div class="dropdown-buttons">
        
        <a class="binder-button" href="https://mybinder.org/v2/gh/executablebooks/jupyter-book/master?urlpath=tree/docs/notebooks/chapter_06/chap_06_notebook.ipynb"><button type="button"
                class="btn btn-secondary topbarbtn" title="Launch Binder" data-toggle="tooltip"
                data-placement="left"><img class="binder-button-logo"
                    src="../../_static/images/logo_binder.svg"
                    alt="Interact on binder">Binder</button></a>
        
        
        
        
    </div>
</div>

        </div>

        <!-- Table of contents -->
        <div class="d-none d-md-block col-md-2 bd-toc show">
            
            <div class="tocsection onthispage pt-5 pb-3">
                <i class="fas fa-list"></i> Contents
            </div>
            <nav id="bd-toc-nav" aria-label="Page">
                <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#feature-detection">
   6.1 Feature Detection
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#global-maxima-minima">
     6.1.1 Global Maxima &amp; Minima
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#local-maximums-minimums">
   6.1.2 Local Maximums &amp; Minimums
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#slopes-inflection-points">
   6.1.3 Slopes &amp; Inflection Points
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#smoothing-data">
     6.2 Smoothing Data
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#unweighted-average">
     6.2.1 Unweighted Average
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#weighted-averages">
     6.2.2 Weighted Averages
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#median-smoothing">
     6.2.3 Median Smoothing
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#savitzkygolay">
     6.2.4 Savitzky–Golay
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fourier-transforms">
   6.3 Fourier Transforms
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#fitting-interpolation">
   6.4 Fitting &amp; Interpolation
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#polynomial-fit">
     6.4.1 Polynomial Fit
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interpolation">
     6.4.3 Interpolation
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#further-reading">
   Further Reading
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#exercises">
   Exercises
  </a>
 </li>
</ul>

            </nav>
        </div>
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="tex2jax_ignore mathjax_ignore section" id="chapter-6-signal-noise">
<span id="id1"></span><h1>Chapter 6: Signal &amp; Noise<a class="headerlink" href="#chapter-6-signal-noise" title="Permalink to this headline">¶</a></h1>
<p>When collecting data from a scientific instrument, a measurement is returned as a value or series of values, and these values are composed of both signal and noise. The signal is the component of interest while the noise is random instrument response resulting from a variety of sources that can include the instrument itself, the sample holder, and even the tiny vibrations of the building. For the most interpretable data, you want the largest signal-to-noise ratio possible in order to reliably identify the features in the data.</p>
<p>This chapter introduces the processing of signal data including detecting features, removing noise from the data, and fitting the data to mathematical models. We will be using the NumPy library in this chapter and also start to use modules from the SciPy library. SciPy, short for “scientific python,” is one of the core libraries in the scientific python ecosystem. This library includes a variety of modules for dealing with signal data, performing Fourier transforms, and integrating sampled data among other common tasks for scientific data analysis. Table 1 summarizes some of the key modules in the SciPy library.</p>
<p><strong>Table 1</strong> Common SciPy Modules</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Module</p></th>
<th class="text-align:left head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">constants()</span></code></p></td>
<td class="text-align:left"><p>Compilation of scientific constants</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">fftpack()</span></code></p></td>
<td class="text-align:left"><p>Fourier transform functions</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">integrate()</span></code></p></td>
<td class="text-align:left"><p>Integration for both functions and sampled data</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">interpolate()</span></code></p></td>
<td class="text-align:left"><p>Data interpolation</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">io()</span></code></p></td>
<td class="text-align:left"><p>File importers and exporters</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">linalg()</span></code></p></td>
<td class="text-align:left"><p>Linear algebra functions</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">optimize()</span></code></p></td>
<td class="text-align:left"><p>ptimization algorithms</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">signal()</span></code></p></td>
<td class="text-align:left"><p>Signal processing functions</p></td>
</tr>
</tbody>
</table>
<p>In contrast to NumPy, each module from SciPy needs to be imported individually, so <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">scipy</span></code> is not going help you much. Instead, you need to do the following to import a module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">module</span>
</pre></div>
</div>
<p>Alternatively, you can import a single function from a module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.module</span> <span class="kn">import</span> <span class="n">function</span>
</pre></div>
</div>
<p>Because NumPy and plotting are used heavily in signal processing, the examples in this chapter assume the following NumPy and matplotlib imports.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline
</pre></div>
</div>
</div>
</div>
<div class="section" id="feature-detection">
<span id="id2"></span><h2>6.1 Feature Detection<a class="headerlink" href="#feature-detection" title="Permalink to this headline">¶</a></h2>
<p>When analyzing experimental data, there are typically key features in the signal that you are most interested in. Often, they are peaks or a series of peaks, but they can also be negative peaks (i.e., low point), the slopes, or an inflection points. This section covers extracting feature information from signal data.</p>
<div class="section" id="global-maxima-minima">
<span id="id3"></span><h3>6.1.1 Global Maxima &amp; Minima<a class="headerlink" href="#global-maxima-minima" title="Permalink to this headline">¶</a></h3>
<p>The simplest and probably most commonly sought after features in signal data are peaks and negative peaks. These are known as the <em>maxima</em> and <em>minima</em>, respectively, or collectively known as the <em>extrema</em>. In the simplest data, there may be only one peak or negative peak, so finding it is a matter of finding the maximum or minimum value in the data. For this, we can use NumPy’s <code class="docutils literal notranslate"><span class="pre">np.maximum()</span></code> and <code class="docutils literal notranslate"><span class="pre">np.minimum()</span></code> functions, and these functions can also be called using the shorter <code class="docutils literal notranslate"><span class="pre">np.max()</span></code> and <code class="docutils literal notranslate"><span class="pre">np.min()</span></code> function calls, respectively.</p>
<p>To demonstrate peak finding, we will use both a <span class="math notranslate nohighlight">\(^{13}\)</span>C{<span class="math notranslate nohighlight">\(^1\)</span>H} Nuclear Magnetic Resonance (NMR) spectrum and an infrared (IR) spectrum. These data are imported below using NumPy.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nmr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="s1">&#39;data/13C_ethanol.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">skip_footer</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">skip_header</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nmr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">nmr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Chemical Shift, ppm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;13C_NMR.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(70.0, 0.0)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_5_1.png" src="../../_images/chap_06_notebook_5_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">genfromtxt</span><span class="p">(</span><span class="s1">&#39;data/IR_acetone.csv&#39;</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ir</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ir</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavenumbers, cm$^{-1}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Transmittance, %&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;ir_acetone.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(4000.0, 600.0)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_7_1.png" src="../../_images/chap_06_notebook_7_1.png" />
</div>
</div>
<p>NMR resonances are positive peaks while IR stretches are represented here as negative peaks, so we can find the largest features in both spectra by finding the maximum value in the NMR spectrum and the smallest value in the IR spectrum.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">nmr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>11.7279863357544
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ir</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>66.80017
</pre></div>
</div>
</div>
</div>
<p>These functions output the max and min values of the independent variable (<span class="math notranslate nohighlight">\(y\)</span>-axis). If we want to know the location on the <span class="math notranslate nohighlight">\(x\)</span>-axes, we need to use the NumPy functions <code class="docutils literal notranslate"><span class="pre">np.argmax()</span></code> and <code class="docutils literal notranslate"><span class="pre">np.argmin()</span></code> which return the indices of the max or min values instead of the actual value (“arg” is short for <em>argument</em>).</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">imax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">nmr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">imax</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>5395
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">imin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">ir</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">imin</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>2302
</pre></div>
</div>
</div>
</div>
<p>With the indices, we can extract the desired information using indexing of the <span class="math notranslate nohighlight">\(x\)</span>-axes. Below, the largest peak in the NMR spectrum is at 18.3 ppm while the smallest transmittance (i.e., largest absorbance) is at 1710 cm<span class="math notranslate nohighlight">\(^{-1}\)</span> in the IR spectrum.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">nmr</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>18.312606267778
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">ir</span><span class="p">[</span><span class="n">imin</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>1710.068
</pre></div>
</div>
</div>
</div>
<p>Below, these values are plotted on the spectra as orange dots to validate that they are indeed the largest features in the spectra.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nmr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">nmr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nmr</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="n">nmr</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Chemical Shift, ppm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;nmr_max.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(70.0, 0.0)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_18_1.png" src="../../_images/chap_06_notebook_18_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ir</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ir</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ir</span><span class="p">[</span><span class="n">imin</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">ir</span><span class="p">[</span><span class="n">imin</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">4000</span><span class="p">,</span> <span class="mi">600</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavenumbers, cm$^{-1}$&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Transmittance, %&#39;</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;ir_min.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0, 0.5, &#39;Transmittance, %&#39;)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_19_1.png" src="../../_images/chap_06_notebook_19_1.png" />
</div>
</div>
<p>Both of these functions find the <em>global extremes</em> (or <em>global extrema</em>). If all you need is the largest feature in a spectrum, this works just fine. To find multiple features, we will need to find the local extrema addressed in the following section.</p>
</div>
</div>
<div class="section" id="local-maximums-minimums">
<span id="id4"></span><h2>6.1.2 Local Maximums &amp; Minimums<a class="headerlink" href="#local-maximums-minimums" title="Permalink to this headline">¶</a></h2>
<p>A considerable amount of data in science contain numerous peaks and negative peaks which are called <em>local extrema</em>. To locate the multiple max and min values, we will use SciPy’s relative max/min functions <code class="docutils literal notranslate"><span class="pre">argrelmax()</span></code> and <code class="docutils literal notranslate"><span class="pre">argrelmin()</span></code>. These functions determine if a point is a max/min by checking a range of data points on both sides to see if the point is the larges/smallest. The range of data points examined is known as the window, and the window can be modified using the <code class="docutils literal notranslate"><span class="pre">order</span></code> argument. Instead of the actual max/min values, these functions return the indices as the “arg” part of the name suggests.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">argrelmax</span><span class="p">,</span> <span class="n">argrelmin</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">imax</span> <span class="o">=</span> <span class="n">argrelmax</span><span class="p">(</span><span class="n">nmr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="mi">2000</span><span class="p">)</span>
<span class="n">imax</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(array([1219, 5395]),)
</pre></div>
</div>
</div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">argrelmax()</span></code> function returned two indices as an array wrapped in a tuple. If we plot the maxima marked with dots, we see that the function correctly identified both peaks.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nmr</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">nmr</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="n">lw</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">nmr</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">nmr</span><span class="p">[</span><span class="n">imax</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="s1">&#39;C1o&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Chemical Shift, ppm&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">70</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;nmr_rel_max.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>(70.0, 0.0)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_25_1.png" src="../../_images/chap_06_notebook_25_1.png" />
</div>
</div>
<p>There are times when the <code class="docutils literal notranslate"><span class="pre">argrelmax()</span></code> function will identify an edge or a point in a flat region as a local maximum because there is nothing larger near it. There are multiple ways to mitigate these erroneous peaks. First, we can increase the window for which the function checks to see if a point is the largest value in its neighborhood. Unfortunately, making the window too large can also prevent the identification of multiple extrema near each other. The second mitigation is to change the function’s mode from the default <code class="docutils literal notranslate"><span class="pre">'clip'</span></code> to <code class="docutils literal notranslate"><span class="pre">'wrap'</span></code>. This makes the function treat the data as wrapped around on itself instead of stopping at the edge. That is, both edges of the data are treated as being connected. This makes it more likely that an extrema value is in the neighborhood.</p>
</div>
<div class="section" id="slopes-inflection-points">
<span id="id5"></span><h2>6.1.3 Slopes &amp; Inflection Points<a class="headerlink" href="#slopes-inflection-points" title="Permalink to this headline">¶</a></h2>
<p>The slope is a useful feature as it can be used to identify inflection points, edges, and make subtle features in a curve more obvious. Noisy data can make it challenging to examine the slope as it causes the slope to fluctuate so much that it sometimes dwarfs the overall signal. It is recommended that the noise be first removed by signal smoothing covered in a section 6.2. To demonstrate the challenges, we will generate both noise-free and noisy synthetic data below and calculate the slopes.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">y_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">y_noisy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.07</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_smooth</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_noisefree.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dca68760&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_29_1.png" src="../../_images/chap_06_notebook_29_1.png" />
</div>
</div>
<p>We will use NumPy to calculate the slope using the <code class="docutils literal notranslate"><span class="pre">np.diff()</span></code> function which calculates the derivative of a user defined order (<code class="docutils literal notranslate"><span class="pre">n</span></code>). Because the slope is the <em>dy/dx</em> between every pair of adjacent points, the resulting slope data is one data point shorter than the original data. This is important when plotting the data because the length of the x and y values must be the same.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dy_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y_smooth</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">dy_noisy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">y_noisy</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">x2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span> <span class="o">/</span> <span class="mi">2</span> <span class="c1"># x values one shorter</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">dy_noisy</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Noisy Data&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">dy_smooth</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Smooth Data&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Slope, dx/dy&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="c1">#plt.savefig(&#39;sine_smoothnoiseoverlay.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fb8dca9cfa0&gt;
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_32_1.png" src="../../_images/chap_06_notebook_32_1.png" />
</div>
</div>
<p>As you can see, the slope from the noise dwarfs that of the main signal. We will use the derivative of the smooth data to find the inflection point below. Because the inflection point in the center of the data has a negative slope, we will need to find the minimum slope. This may not always be the case with other data.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dy_smooth</span><span class="p">)</span>  <span class="c1"># finds min slope</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_smooth</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">y_smooth</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_inflection.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dce60c70&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_34_1.png" src="../../_images/chap_06_notebook_34_1.png" />
</div>
</div>
<div class="section" id="smoothing-data">
<span id="id6"></span><h3>6.2 Smoothing Data<a class="headerlink" href="#smoothing-data" title="Permalink to this headline">¶</a></h3>
<p>It is not uncommon to collect signal data that has a considerable amount of noise in it. Smoothing the data can help in the processing and analysis of the data such as making it easier to identify peaks or preventing the noise from hiding the extremes in the derivative of the data. Smoothing alters the actual data, so it is important to be transparent to others that the data were smoothed and how they were smoothed.</p>
<p>There are a variety of ways to smooth data including moving averages, band filters, and the Savitzky-Golay filter. We will focus on moving averages and Savitzky-Golay here. For this section, we will work with synthetic data with random noise generated below.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">+</span> <span class="mf">0.7</span> <span class="o">*</span> <span class="p">(</span><span class="n">noise</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_unsmoothed.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dcf68580&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_37_1.png" src="../../_images/chap_06_notebook_37_1.png" />
</div>
</div>
</div>
<div class="section" id="unweighted-average">
<span id="id7"></span><h3>6.2.1 Unweighted Average<a class="headerlink" href="#unweighted-average" title="Permalink to this headline">¶</a></h3>
<p>The first and simplest way to smooth data is to <em>moving average</em> each data point with its immediate neighbors. This is an <em>unweighted sliding average smooth</em> or a <em>rectangular boxcar smooth</em>. From noisy data point <span class="math notranslate nohighlight">\(D_j\)</span>, we get smoothed data point <span class="math notranslate nohighlight">\(S_j\)</span> by the following equation where <span class="math notranslate nohighlight">\(D_{j-1}\)</span> and <span class="math notranslate nohighlight">\(D_{j+1}\)</span> are the points immediately preceding and following a data point <span class="math notranslate nohighlight">\(D_j\)</span>, respectively.</p>
<div class="math notranslate nohighlight">
\[ S_j = \frac{D_{j-1} + D_j + D_{j+1}}{3} \]</div>
<p>One thing to note about this smoothing method is that it is only valid for all points except the first and last because there are no data points both before and after them to take the average with. As a result, the smoothed data is two data points shorter. There are approximations that can be used to maintain the length of the data, but for simplicity, we will allow the data to shorten.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:]</span>
<span class="n">rect_smooth</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">3</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">rect_smooth</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_rectSmooth.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dd11a310&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_39_1.png" src="../../_images/chap_06_notebook_39_1.png" />
</div>
</div>
<p>The data is smoothed relative to the original data, but there is still a considerable amount of noise present.</p>
</div>
<div class="section" id="weighted-averages">
<span id="id8"></span><h3>6.2.2 Weighted Averages<a class="headerlink" href="#weighted-averages" title="Permalink to this headline">¶</a></h3>
<p>The above method treats each point equally and only takes the average with the immediately adjacent data points. The <em>triangular smooth</em> approach averages extra data points with the points closer to the original point weighted more heavily than those further away. For example, if we take the average using five data points, this is described by the following equation.</p>
<div class="math notranslate nohighlight">
\[ S_j = \frac{D_{j-2} + 2D_{j-1} + 3D_j + 2D_{j+1} + D_{j+2}}{9} \]</div>
<p>The resulting data is shortened by four points as the end points have insufficient neighbors to be averaged.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">sum</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
<span class="n">tri_smooth</span> <span class="o">=</span> <span class="nb">sum</span> <span class="o">/</span> <span class="mi">9</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="o">-</span><span class="mi">2</span><span class="p">],</span> <span class="n">tri_smooth</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_triSmooth.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dd1a8e20&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_42_1.png" src="../../_images/chap_06_notebook_42_1.png" />
</div>
</div>
<p>The triangular smooth results in a smoother data set than the rectangular smooth. This is not surprising as applying the triangular smooth above is mathematically equivalent to applying the rectangular smooth twice.</p>
</div>
<div class="section" id="median-smoothing">
<span id="id9"></span><h3>6.2.3 Median Smoothing<a class="headerlink" href="#median-smoothing" title="Permalink to this headline">¶</a></h3>
<p>While the above filters take some form of the mean of the surrounding data points, a median filter takes the median. This filter is sometimes applied to images because it reduces noise while maintaining sharp edges.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">array2d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">:],</span> <span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">data</span><span class="p">[:</span><span class="o">-</span><span class="mi">2</span><span class="p">]))</span>
<span class="n">median_smooth</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">array2d</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">median_smooth</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_medSmooth.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dd355160&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_45_1.png" src="../../_images/chap_06_notebook_45_1.png" />
</div>
</div>
</div>
<div class="section" id="savitzkygolay">
<span id="id10"></span><h3>6.2.4 Savitzky–Golay<a class="headerlink" href="#savitzkygolay" title="Permalink to this headline">¶</a></h3>
<p>Another approach is the <em>Savitzky–Golay</em> filter which incrementally moves along the noisy data and fits sections (i.e.., windows) of data points to a polynomial using least square minimization. While this approach had been previously described in the mathematical literature, Abraham Savitzky and M. J. E. Golay are known for <a class="reference external" href="https://doi.org/10.1021/ac60214a047">applying it to spectroscopy</a>. Conveniently, SciPy contains a built-in function for this called <code class="docutils literal notranslate"><span class="pre">savgol_filter()</span></code> from the signal module shown below.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">scipy</span><span class="o">.</span><span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="p">)</span>
</pre></div>
</div>
<p>This function requires three arguments which include the original data as a NumPy array, <code class="docutils literal notranslate"><span class="pre">window</span></code> which is the width of the moving window the savgol algorithm fits to a polynomial, and <code class="docutils literal notranslate"><span class="pre">polyorder</span></code> which is the order of <code class="docutils literal notranslate"><span class="pre">polynomial</span></code> used for the moving data fit. You are encouraged to play with the window and polyorder arguments to see what works the best for your application. However, polyorder must be less than the window size, and the <code class="docutils literal notranslate"><span class="pre">window</span></code> must be an odd integer.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">savgol_filter</span>
<span class="n">sg_smooth</span> <span class="o">=</span> <span class="n">savgol_filter</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">51</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sg_smooth</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_sgSmooth.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8dcb75340&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_48_1.png" src="../../_images/chap_06_notebook_48_1.png" />
</div>
</div>
</div>
</div>
<div class="section" id="fourier-transforms">
<span id="id11"></span><h2>6.3 Fourier Transforms<a class="headerlink" href="#fourier-transforms" title="Permalink to this headline">¶</a></h2>
<p>Another approach to filtering noise is to filter based on frequency. Many times, random noise in data occurs at a different frequency than the data itself, and the noise can be reduced by filtering noise frequency ranges while maintaining signal frequencies. Often times, the random noise is higher frequency than the signal, so filtering out higher frequency noise is known as a <em>low-pass</em> filter. Alternatively, filtering out low-frequency noise is known as a <em>high-pass</em> filter, and filtering out noise above and blow the signal frequency is known as a <em>band-pass</em> filter. Frequency filtering is somewhat involved being that we need to use window functions which are covered in the <a class="reference external" href="https://greenteapress.com/wp/think-dsp/">Think DSP</a> book by Allen Downey listed at the end of this chapter. Instead, we will just look at the distribution of signal and noise frequencies in synthetic data. This is useful for analyzing the noise in data and also is used routinely in nuclear magnetic resonance (NMR) spectroscopy and Fourier Transform infrared spectroscopy (FTIR).</p>
<p>To convert the data from the time domain to the frequency domain, we will use the <em>fast Fourier transform (FFT)</em> algorithm. This algorithm is only for data that is periodic.  Below, synthetic data is generated oscillating at 62.0 Hz with some random noise to make it more interesting.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="mf">62.0</span>  <span class="c1"># Hz</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">freq</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">+</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">noise</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Time, s&#39;</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_for_FT.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;Time, s&#39;)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_51_1.png" src="../../_images/chap_06_notebook_51_1.png" />
</div>
</div>
<p>SciPy contains an entire module called <code class="docutils literal notranslate"><span class="pre">fftpack</span></code> dedicated to Fourier transforms and reverse Fourier transforms. We will use the basic <code class="docutils literal notranslate"><span class="pre">fft()</span></code> function for our synthetic data which returns a mixture of real and imaginary values. For plotting, we will simply look at the real component of the result using <code class="docutils literal notranslate"><span class="pre">.real</span></code>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">fft</span>
<span class="n">fdata</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">fdata</span><span class="o">.</span><span class="n">real</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">500</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency, Hz&#39;</span><span class="p">)</span>

<span class="c1">#plt.savefig(&#39;sine_freqDomain.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>Text(0.5, 0, &#39;Frequency, Hz&#39;)
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_53_1.png" src="../../_images/chap_06_notebook_53_1.png" />
</div>
</div>
<p>Only the first half of the Fourier transform output is plotted above because the second half is a mirror image of the first. A single peak at 62.0 Hz is represent from our signal. The rest of the baseline of the plot is not smooth because there is noise present at a variety of frequencies. It is important to note that the erratic variations in the baseline of the frequency plot is not the noise itself but more like a histogram of all the frequencies present in the original data.</p>
</div>
<div class="section" id="fitting-interpolation">
<span id="id12"></span><h2>6.4 Fitting &amp; Interpolation<a class="headerlink" href="#fitting-interpolation" title="Permalink to this headline">¶</a></h2>
<p>Signal data or information taken from signal data often conforms to linear, polynomial, or other mathematical trends, and fitting data is important because it allows scientists to determine the equation describing the physical or chemical behavior of the data. In <em>data fitting</em>, the user provides the data and the general class of equation expected, and the software returns the <em>coefficients</em> for the equation. <em>Interpolation</em> is the method of predicting values in regions among known data points. The calculation of values where no data was collected can be accomplished by either using the coefficients derived from a curve fit or using a special interpolation function that generates a callable function to calculate the new data points. Both approaches are demonstrated below.</p>
<div class="section" id="polynomial-fit">
<span id="id13"></span><h3>6.4.1 Polynomial Fit<a class="headerlink" href="#polynomial-fit" title="Permalink to this headline">¶</a></h3>
<p>Before we can do our fitting, we need some new, noisy data to examine. A linear set of data with added noise is generated below along with a second-order curve with the same noise.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>
<span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span>
<span class="n">y_noisy</span> <span class="o">=</span> <span class="mf">2.2</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">noise</span>
<span class="n">y2_noisy</span> <span class="o">=</span> <span class="mf">3.4</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="mi">7</span> <span class="o">+</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">noise</span>
        
<span class="c1">#plt.savefig(&#39;polyfit_scatter.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_noisy</span><span class="p">)</span>
<span class="c1">#plt.savefig(&#39;curve_scatter.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.PathCollection at 0x7fb8dd6e25e0&gt;
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_57_1.png" src="../../_images/chap_06_notebook_57_1.png" />
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y2_noisy</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.collections.PathCollection at 0x7fb8de820070&gt;
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_58_1.png" src="../../_images/chap_06_notebook_58_1.png" />
</div>
</div>
<p>Now we can fit the noisy data with a line using the NumPy <code class="docutils literal notranslate"><span class="pre">polyfit(x,</span> <span class="pre">y,</span> <span class="pre">degree)</span></code> function. The function takes the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> data along with the <code class="docutils literal notranslate"><span class="pre">degree</span></code> of the polynomial.</p>
<p>A line is a first-degree polynomial, and the function returns an array containing the coefficients for the fit with the highest order coefficients first.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_noisy</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([2.17737224, 1.65642513])
</pre></div>
</div>
</div>
</div>
<p>For a linear equation of the form y = ax + b, we get an array of the form <code class="docutils literal notranslate"><span class="pre">array([a,</span> <span class="pre">b])</span></code>, so the fitted equation above is <span class="math notranslate nohighlight">\(y = 2.2x + 1\)</span>. The positive shift of the <span class="math notranslate nohighlight">\(y\)</span>-intercept above zero is not surprising being that we added random noise not centered around zero; the average of our <code class="docutils literal notranslate"><span class="pre">np.random.rand()</span></code> noise should be around 0.5, not zero. This could be remedied either by subtracting 0.5 from the noise or using another random number generator such as the normal distribution, such as <code class="docutils literal notranslate"><span class="pre">randn()</span></code>, which is centered around zero. We can also obtain the statistics for our fit using the <code class="docutils literal notranslate"><span class="pre">linregress()</span></code> function from the SciPy <code class="docutils literal notranslate"><span class="pre">stats</span></code> module. Note that this does not returns the <span class="math notranslate nohighlight">\(r^2\)</span> value but instead the <span class="math notranslate nohighlight">\(r\)</span>-value which can be squared to generate the <span class="math notranslate nohighlight">\(r^2\)</span> value.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">stats</span>
<span class="n">stats</span><span class="o">.</span><span class="n">linregress</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y_noisy</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>LinregressResult(slope=2.1773722394976947, intercept=1.6564251333995994, rvalue=0.9908493119330185, pvalue=4.712440428804615e-87, stderr=0.029961123989056915, intercept_stderr=0.1734168996240727)
</pre></div>
</div>
</div>
</div>
<p>Fitting to a polynomial of a higher order works the same way except that the order is above one. Below, the <code class="docutils literal notranslate"><span class="pre">polyfit()</span></code> function determines the equation to be <span class="math notranslate nohighlight">\(y = 3.4x2 + 3.7x + 13\)</span>.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y2_noisy</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>array([3.42028533, 3.77451897, 8.99109887])
</pre></div>
</div>
</div>
</div>
</div>
<div class="section" id="interpolation">
<span id="id14"></span><h3>6.4.3 Interpolation<a class="headerlink" href="#interpolation" title="Permalink to this headline">¶</a></h3>
<p>The practical difference between the <code class="docutils literal notranslate"><span class="pre">np.polyfit</span></code> function and the interpolation functions in SciPy is that the former returns coefficients for the equation while the interpolation functions return a Python function that can be used to calculate values. There are times when one is more desirable than the other depending upon your application. Below we will use the interpolation function to interpolate a one dimensional function.</p>
<p>Below is a dampening sine wave that we will interpolate from ten data points.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">/</span><span class="n">x</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">)</span>
        
<span class="c1">#plt.savefig(&#39;sine_wave_samples.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>[&lt;matplotlib.lines.Line2D at 0x7fb8de8febe0&gt;]
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_66_1.png" src="../../_images/chap_06_notebook_66_1.png" />
</div>
</div>
<p>To interpolate this one-dimensional function, we will use the <code class="docutils literal notranslate"><span class="pre">interp1d()</span></code> method from SciPy. Along with the <code class="docutils literal notranslate"><span class="pre">x</span></code> and <code class="docutils literal notranslate"><span class="pre">y</span></code> values, <code class="docutils literal notranslate"><span class="pre">interp1d()</span></code> requires a mode of interpolation using the kind keyword which can include the items listed in Table 2.</p>
<p><strong>Table 2 Modes</strong> for <code class="docutils literal notranslate"><span class="pre">interp1d()</span></code> Method</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Kind</p></th>
<th class="text-align:left head"><p>Description</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">linear()</span></code></p></td>
<td class="text-align:left"><p>Linear interpolation between data points</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">zero()</span></code></p></td>
<td class="text-align:left"><p>Constant value until the next data point</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">nearest()</span></code></p></td>
<td class="text-align:left"><p>Predicts values equaling the closest data point</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">quadratic()</span></code></p></td>
<td class="text-align:left"><p>Interpolates with a second-order spline</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p><code class="docutils literal notranslate"><span class="pre">cubic()</span></code></p></td>
<td class="text-align:left"><p>Interpolates with a third-order spline</p></td>
</tr>
</tbody>
</table>
<p>Below is a demonstration of both linear and cubic interpolation. The two functions <code class="docutils literal notranslate"><span class="pre">f()</span></code> and <code class="docutils literal notranslate"><span class="pre">f2()</span></code> are generated and can be used like any other Python function to calculate values.</p>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">interpolate</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;cubic&#39;</span><span class="p">)</span>
<span class="c1">#f3 = interpolate.interp1d(x, y, kind=&#39;nearest&#39;)</span>
</pre></div>
</div>
</div>
</div>
<div class="cell docutils container">
<div class="cell_input docutils container">
<div class="highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">xnew</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">20</span><span class="p">,</span><span class="mi">100</span><span class="p">)</span>

<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">f</span><span class="p">(</span><span class="n">xnew</span><span class="p">),</span> <span class="s1">&#39;C1-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Linear Interpolation&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">xnew</span><span class="p">,</span> <span class="n">f2</span><span class="p">(</span><span class="n">xnew</span><span class="p">),</span> <span class="s1">&#39;C2--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Cubic Interpolation&#39;</span><span class="p">)</span>
<span class="c1">#plt.plot(xnew, f3(xnew), &#39;C2-&#39;, label=&#39;Nearest Interpolation&#39;)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Sampled Data&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>

<span class="c1">#plt.savefig(&#39;interp1d.png&#39;, dpi=300, format=&#39;PNG&#39;)</span>
</pre></div>
</div>
</div>
<div class="cell_output docutils container">
<div class="output text_plain highlight-myst-ansi notranslate"><div class="highlight"><pre><span></span>&lt;matplotlib.legend.Legend at 0x7fb8de9aeeb0&gt;
</pre></div>
</div>
<img alt="../../_images/chap_06_notebook_69_1.png" src="../../_images/chap_06_notebook_69_1.png" />
</div>
</div>
</div>
</div>
<div class="section" id="further-reading">
<h2>Further Reading<a class="headerlink" href="#further-reading" title="Permalink to this headline">¶</a></h2>
<p>The ultimate authority on NumPy and SciPy are the Numpy &amp; SciPy Documentation page listed below. As changes and improvements occur in these libraries, this is one of the best places to find information. For information on digital signal processing (DSP), there are numerous sources such as Allen Downey’s Think DSP book or articles such as those listed below.</p>
<ol class="simple">
<li><p>Numpy and Scipy Documentation. <a class="reference external" href="https://docs.scipy.org/doc/">https://docs.scipy.org/doc/</a> (free resource)</p></li>
<li><p>Downey, Allen B. Think DSP, Green Tea Press, 2016. <a class="reference external" href="https://docs.scipy.org/doc/">http://greenteapress.com/wp/think-dsp/</a> (free resource)</p></li>
<li><p>O’Haver, T. C. An Introduction to Signal Processing in Chemical Measurement. <em>J. Chem. Educ.</em> <strong>1991,</strong> 68 (6), A147-A150. <a class="reference external" href="https://doi.org/10.1021/ed068pA147">https://doi.org/10.1021/ed068pA147</a></p></li>
<li><p>Savitzky, A.; Golay, M.J.E. Smoothing and Differentiation of Data by Simplified Least Squares Procedures. <em>Anal. Chem.</em> <strong>1964,</strong> 36 (8) 1627–1639. <a class="reference external" href="https://doi.org/10.1021/ac60214a047">https://doi.org/10.1021/ac60214a047</a></p></li>
</ol>
</div>
<div class="section" id="exercises">
<h2>Exercises<a class="headerlink" href="#exercises" title="Permalink to this headline">¶</a></h2>
<p>Solve the following problems using Python in a Jupyter notebook.</p>
<ol>
<li><p>Import the file <strong>CV_K3Fe(CN)6.csv</strong> which contains a cyclic voltammogram for potassium cyanoferrate. Plot the data with the green dots on the highest point(s) and red triangles on the lowest point(s).</p></li>
<li><p>Import the file titled <strong>CV_K3Fe(CN)6.csv</strong> and determine the inflection point. Plot the data with a marker on the inflection point.</p></li>
<li><p>Generate noisy synthetic data from the following code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">sawtooth</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="n">sig</span> <span class="o">=</span> <span class="n">sawtooth</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
<p>a) Smooth the data using moving averages and plot the smoothed signal. Feel free to use the moving averages code     from this chapter.</p>
<p>b) Smooth the same data using a Savitzky–Golay filter. Plot the smoothed signal.</p>
</li>
<li><p>Import the <span class="math notranslate nohighlight">\(^{31}\)</span>P NMR file titled <strong>fid_31P.csv</strong> and determine the number of major frequencies are in this wave. Keep in mind that there will be a second echo for each peak.</p></li>
<li><p>The wavelength of emitted light (<span class="math notranslate nohighlight">\(\lambda\)</span>) from hydrogen is related to the electron energy level transitions by the following equation where R<span class="math notranslate nohighlight">\(_\infty\)</span> is the Rydberg constant, ni is the initial principle quantum number of the electron, and nf is the final principle quantum number of the electron.</p>
<div class="math notranslate nohighlight">
\[ \frac{1}{\lambda} = R_\infty \left(\frac{1}{n_f^2} - \frac{1}{n_i^2} \right) \]</div>
<p>The following is experimental data of the wavelengths for five different transitions from the Balmer series         (i.e., nf = 2).</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Transition (<span class="math notranslate nohighlight">\(n_i\)</span> <span class="math notranslate nohighlight">\(\rightarrow\)</span> <span class="math notranslate nohighlight">\(n_2\)</span>)</p></th>
<th class="text-align:center head"><p>Wavelength (nm)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>3 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2</p></td>
<td class="text-align:center"><p>656.1</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>4 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2</p></td>
<td class="text-align:center"><p>485.2</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>5 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2</p></td>
<td class="text-align:center"><p>433.2</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>6 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2</p></td>
<td class="text-align:center"><p>409.1</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>7 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2</p></td>
<td class="text-align:center"><p>396.4</p></td>
</tr>
</tbody>
</table>
<p>Calculate a value for the Rydberg constant (R∞) using a linear fit of the above data. The data will need to be       first linearized.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">n_i</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">]</span>
<span class="n">wl</span> <span class="o">=</span> <span class="p">[</span><span class="mf">656.1</span><span class="p">,</span> <span class="mf">485.2</span><span class="p">,</span> <span class="mf">433.2</span><span class="p">,</span> <span class="mf">409.1</span><span class="p">,</span> <span class="mf">396.4</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>The following data is for the initial rate of a chemical reaction for different concentrations of starting material (A). Calculate a rate constant (k) for this reaction using a nonlinear fit.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Conc A (M)</p></th>
<th class="text-align:center head"><p>Rate (M/s)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>0.10</p></td>
<td class="text-align:center"><p>0.0034</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>0.16</p></td>
<td class="text-align:center"><p>0.0087</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>0.20</p></td>
<td class="text-align:center"><p>0.014</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>0.25</p></td>
<td class="text-align:center"><p>0.021</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>0.41</p></td>
<td class="text-align:center"><p>0.057</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>0.55</p></td>
<td class="text-align:center"><p>0.10</p></td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">conc</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.10</span><span class="p">,</span> <span class="mf">0.16</span><span class="p">,</span> <span class="mf">0.20</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.41</span><span class="p">,</span> <span class="mf">0.55</span><span class="p">]</span>
<span class="n">rate</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0034</span><span class="p">,</span> <span class="mf">0.0087</span><span class="p">,</span> <span class="mf">0.014</span><span class="p">,</span> <span class="mf">0.021</span><span class="p">,</span> <span class="mf">0.057</span><span class="p">,</span> <span class="mf">0.10</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>A colorimeter exhibits the following absorbances for known concentrations of Red 40 food dye. Generate a calibration curve using the data below and then calculate the concentration of Red 40 dye in a pink soft drink with an absorbance of 0.181.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Absorb.  (&#64; 504 nm)</p></th>
<th class="text-align:center head"><p>Red 40 (10<span class="math notranslate nohighlight">\(^{-5}\)</span> M)</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>0.125</p></td>
<td class="text-align:center"><p>0.150</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>0.940</p></td>
<td class="text-align:center"><p>1.13</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>2.36</p></td>
<td class="text-align:center"><p>2.84</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>2.63</p></td>
<td class="text-align:center"><p>3.16</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>3.31</p></td>
<td class="text-align:center"><p>3.98</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>3.77</p></td>
<td class="text-align:center"><p>4.53</p></td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.125</span><span class="p">,</span> <span class="mf">0.940</span><span class="p">,</span> <span class="mf">2.36</span><span class="p">,</span> <span class="mf">2.63</span><span class="p">,</span> <span class="mf">3.31</span><span class="p">,</span> <span class="mf">3.77</span><span class="p">]</span>
<span class="n">conc</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.150</span><span class="p">,</span> <span class="mf">1.13</span><span class="p">,</span> <span class="mf">2.84</span><span class="p">,</span> <span class="mf">3.16</span><span class="p">,</span> <span class="mf">3.98</span><span class="p">,</span> <span class="mf">4.53</span><span class="p">]</span>
</pre></div>
</div>
</li>
<li><p>The following are points on the 2s radial wave function (<span class="math notranslate nohighlight">\(\Psi\)</span>) for a hydrogen atom with respect to the radial distance from the nucleus in Bohrs (<span class="math notranslate nohighlight">\(a_0\)</span>). Visualize the radial wave function as a smooth curve by interpolating the following data points.</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="text-align:center head"><p>Radius (<span class="math notranslate nohighlight">\(a_0\)</span>)</p></th>
<th class="text-align:center head"><p><span class="math notranslate nohighlight">\(\Psi\)</span></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td class="text-align:center"><p>1.0</p></td>
<td class="text-align:center"><p>0.21</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>5.0</p></td>
<td class="text-align:center"><p>-0.087</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>9.0</p></td>
<td class="text-align:center"><p>-0.027</p></td>
</tr>
<tr class="row-odd"><td class="text-align:center"><p>13.0</p></td>
<td class="text-align:center"><p>-0.0058</p></td>
</tr>
<tr class="row-even"><td class="text-align:center"><p>17.0</p></td>
<td class="text-align:center"><p>-0.00108</p></td>
</tr>
</tbody>
</table>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">radius</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">,</span> <span class="mf">9.0</span><span class="p">,</span> <span class="mf">13.0</span><span class="p">,</span> <span class="mf">17.0</span><span class="p">]</span>
<span class="n">psi</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.21</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.087</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.027</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.0058</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.00108</span><span class="p">]</span>
</pre></div>
</div>
</li>
</ol>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./notebooks/chapter_06"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        
            <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../chapter_05/chap_05_notebook.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Chapter 5: Pandas</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../chapter_07/chap_07_notebook.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Chapter 7: Image Processing &amp; Analysis</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
        
        </div>
    </div>
    <footer class="footer">
    <div class="container">
      <p>
        
          By Charles J. Weiss<br/>
        
            &copy; Copyright 2021.<br/>
          <div class="extra_footer">
            Scientific Computing for Chemists is licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/](https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a>
          </div>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>
  
  <script src="../../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>

  </body>
</html>